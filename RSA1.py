def decrypt(d, N, cipher):
   
    msg = pow(c, d, N)
    flag = long_to_bytes(msg)
    return flag

def modular_inverse(a, b):
	r0 = b; r1 = a
	x1 = 0; x0 = 1
	y1 = 1; y0 = 0

	
	while r0 != 0:
		q = r1 // r0
		r1, r0 = r0, r1 - q * r0
		x0, x1 = x1, x0 - q * x1
		y0, y1 = y1, y0 - q * y1

	if x0 < 0:
		x0 += b

	return x0
n = 60351543895459542434310165670916884826452101303302769252591449955891484917592917542768059729730725361556737759950111421530786068576204908607958316040329269
c = 10703217163753660193627358572383126125007620021360074658097720175359018869786998455196379928219000099549251744904227314022432191941073235008984566976473513
phiN = 60351543895459542434310165670916884826452101303302769252591449955891484917592062993950767785628502163671370384097827901159851717819166992465188435144445196
d = modular_inverse(5, phiN)

print(decrypt(c, d, n))

# 34323038553046752410241649767995377252753709101318392286132036107810250300954101157180346146243221988583850724772532814390232793555369981040639827943402588